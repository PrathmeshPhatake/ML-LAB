# 9. Write a program to do the following: You have given a collection of 8
# points. P1=[0.1,0.6] P2=[0.15,0.71] P3=[0.08,0.9] P4=[0.16, 0.85]
# P5=[0.2,0.3] P6=[0.25,0.5] P7=[0.24,0.1] P8=[0.3,0.2]. Perform the k-mean
# clustering with initial centroids as m1=P1 =Cluster#1=C1 and
# m2=P8=cluster#2=C2. Answer the following 1] Which cluster does P6
# belong to? 2] What is the population of a cluster around m2? 3] What is
# the updated value of m1 and m2?
# Ecludian formula sqrt((x2-x1)^2+(y2-y1)^2) choes minumum
import numpy as np
import math

import numpy as np

# Step 1: Define points
points = {
    "P1": [0.1, 0.6],
    "P2": [0.15, 0.71],
    "P3": [0.08, 0.9],
    "P4": [0.16, 0.85],
    "P5": [0.2, 0.3],
    "P6": [0.25, 0.5],
    "P7": [0.24, 0.1],
    "P8": [0.3, 0.2]
}

# Initial centroids
centroid_1 = np.array(points["P1"])
centroid_2 = np.array(points["P8"])

# Step 2: Distance function
def euclidean_distance(p1, p2):
    return np.sqrt(np.sum((p1 - p2) ** 2))

# Step 3: Assign points to clusters
clusters = {"C1": [], "C2": []}

for key, point in points.items():
    point = np.array(point)
    dist_to_c1 = euclidean_distance(point, centroid_1)
    dist_to_c2 = euclidean_distance(point, centroid_2)
    if dist_to_c1 <= dist_to_c2:
        clusters["C1"].append(key)
    else:
        clusters["C2"].append(key)

# Step 4: Recompute centroids
def recompute_centroid(cluster_points):
    cluster_coords = [np.array(points[p]) for p in cluster_points]
    return np.mean(cluster_coords, axis=0)

new_centroid_1 = recompute_centroid(clusters["C1"])
new_centroid_2 = recompute_centroid(clusters["C2"])

# Output Results
print(f"Cluster assignments:\nC1: {clusters['C1']}\nC2: {clusters['C2']}")
print(f"Updated centroids:\nCentroid 1: {new_centroid_1}\nCentroid 2: {new_centroid_2}")
print(f"P6 belongs to cluster: {'C1' if 'P6' in clusters['C1'] else 'C2'}")
print(f"Population around m2 (C2): {len(clusters['C2'])}")
